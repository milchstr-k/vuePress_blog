---
icon: pen-to-square
date: 2024-01-07 16:35
category:
  - Java
tag:
  - 线程池
---

# 确定线程池线程数
## 线程池分类
使用**ThreadPoolExecutor**创建线程池的时候，会涉及线程数的配置，线程数的配置与异步任务类型有关。将线程池异步任务分为三类:
* IO密集型任务
    * 主要执行IO操作，耗费时间较长，CPU利用率不高，CPU常处于空闲状态。Netty的读写操作为此类任务典型例子。
* CPU密集型任务
    * 主要执行计算任务，由于响应时间很快，CPU一直在运行，CPU利用率很高。
* 混合型任务
    * 既执行逻辑计算，又要进行IO操作（RPC调用，数据库访问）。由于执行IO操作比较耗时，这类任务的CPU利用率也不是很高。WEB服务的HTTP请求处理操作为此类任务典型例子。

## IO密集型任务确认线程数

* IO操作的特性：IO密集型任务通常是由于等待IO操作而阻塞的，因此可以通过增加线程数来提高并发处理能力。但是，如果线程数目过多，可能会增加上下文切换的开销，反而降低性能。
* IO密集型任务的CPU使用率低下，线程空余时间多，可以**开启CPU核心数两倍的线程**。IO线程空闲时，启用其他线程继续使用CPU，提高CPU的使用率。
* Netty的IO处理任务就是典型的IO密集型任务。所以，Netty的Reactor（反应器）实现类（定制版的线程池）的IO处理线程数默认正好为CPU核数的两倍，以下是其相关的代码：
```java
//多线程版本Reactor实现类
public abstract class MultithreadEventLoopGroup extends
        MultithreadEventExecutorGroup implements EventLoopGroup {

    //IO事件处理线程数
    private static final int DEFAULT_EVENT_LOOP_THREADS;

    //IO事件处理线程数默认值为CPU核数的两倍
    static {
        DEFAULT_EVENT_LOOP_THREADS = Math.max(1,
                SystemPropertyUtil.getInt("io.netty.eventLoopThreads",
                Runtime.getRuntime().availableProcessors() * 2));
    }

    /**
     *构造器
    */
    protected MultithreadEventLoopGroup(int nThreads, 
                ThreadFactory threadFactory, Object... args) {
        super(nThreads == 0?
                DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);
    }
// 省略其他
}

```

IO密集型任务简单线程池：
```java

public class ThreadUtil
{
    //CPU核数
    private static final int CPU_COUNT =
                                    Runtime.getRuntime().availableProcessors();
    //IO处理线程数
    private static final int IO_MAX = Math.max(2, CPU_COUNT * 2);
    /**
     * 空闲保活时限，单位秒
     */
    private static final int KEEP_ALIVE_SECONDS = 30;
    /**
     * 有界队列size
     */
    private static final int QUEUE_SIZE = 128;
    //懒汉式单例创建线程池：用于IO密集型任务
    private static class IoIntenseTargetThreadPoolLazyHolder
    {
        //线程池： 用于IO密集型任务
        private static final ThreadPoolExecutor EXECUTOR =
                                                        new ThreadPoolExecutor(
                IO_MAX,  //CPU核数*2
                IO_MAX,  //CPU核数*2
                KEEP_ALIVE_SECONDS,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue(QUEUE_SIZE),
                new CustomThreadFactory("io"));

        static
        {
            EXECUTOR.allowCoreThreadTimeOut(true);
            //JVM关闭时的钩子函数
            Runtime.getRuntime().addShutdownHook(
                    new ShutdownHookThread("IO密集型任务线程池",
                                                                new Callable<Void>()
                    {
                        @Override
                        public Void call() throws Exception
                        {
                            //优雅地关闭线程池
                            shutdownThreadPoolGracefully(EXECUTOR);
                            return null;
                        }
                    }));
        }
    }
    // 省略不相干代码
}


```

在以上代码中：
* 1. 调用了allowCoreThreadTimeOut(…)方法，并且传入了参数true，则keepAliveTime参数所设置的Idle超时策略也将被应用于核心线程，当池中的线程长时间空闲时，可以自行销毁。
* 2.使用有界队列缓冲任务而不是无界队列。使用无界队列的危害：
    * 内存消耗：无界队列没有容量限制，可以无限添加任务。如果任务的生产速度超过了线程的处理速度，队列中的任务将会无限增长，占用大量的内存资源。这可能导致内存溢出或系统资源耗尽。
    * 队列过载：当使用无界队列时，如果任务的到达速度远远超过了线程池的处理能力，队列可能会过载。这会导致任务在队列中等待的时间过长，影响任务的响应性和系统的吞吐量。
    * 内存泄漏：当使用无界队列时，如果任务产生的速度始终大于处理的速度，那么队列将会不断增长，即使有些任务已经完成或取消，其引用仍然存在于队列中，可能导致内存泄漏。
    * 公平性问题：无界队列是一个公平的队列，即等待时间较长的任务将在队列中等待较长时间。这可能导致某些任务的响应时间较长，不利于响应时间敏感的应用。
* 3.corePoolSize和maximumPoolSize保持一致，使得在接收到新任务时，如果没有空闲工作线程，就优先创建新的线程去执行新任务，而不是优先加入阻塞队列，等待现有工作线程空闲后再执行。
* 4.使用懒汉式单例模式创建线程池，如果代码没有用到此线程池，就不会立即创建。
* 5.使用JVM关闭时的钩子函数优雅地自动关闭线程池。

## CPU密集型任务确定线程数
CPU密集型任务也叫计算密集型任务，其特点是要进行大量计算而需要消耗CPU资源，比如计算圆周率，对视频进行高清解码等。高效利用CPU，并行执行的数量应当等于CPU核心数，减少上下文切换时间。

CPU密集型线程池：
```java

public class ThreadUtil
{
    //CPU核数
    private static final int CPU_COUNT =
                                    Runtime.getRuntime().availableProcessors();

    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT;

    //懒汉式单例创建线程池：用于CPU密集型任务
    private static class CpuIntenseTargetThreadPoolLazyHolder
    {
        //线程池：用于CPU密集型任务
        private static final ThreadPoolExecutor EXECUTOR = 
                                                        new ThreadPoolExecutor(
                MAXIMUM_POOL_SIZE,
                MAXIMUM_POOL_SIZE,
                KEEP_ALIVE_SECONDS,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue(QUEUE_SIZE),
                new CustomThreadFactory("cpu"));

        static
        {
            EXECUTOR.allowCoreThreadTimeOut(true);
            //JVM关闭时的钩子函数
            Runtime.getRuntime().addShutdownHook(
                    new ShutdownHookThread("CPU密集型任务线程池",
                                                            new Callable<Void>()
                    {
                        @Override
                        public Void call() throws Exception
                        {
                            //优雅地关闭线程池
                            shutdownThreadPoolGracefully(EXECUTOR);
                            return null;
                        }
                    }));
        }
    }
    // 省略不相干代码
}


```


## 混合型任务确定线程数

业界的一个比较成熟的估算方式：

     最佳线程数 = ((线程等待时间+线程CPU时间) / 线程CPU时间) * CPU核数
     
进一步转换为：

     最佳线程数目 = (线程等待时间与线程CPU时间之比 + 1) * CPU核数

通过公式可以看出：等待时间所占的比例越高，需要的线程就越多；CPU耗时所占的比例越高，需要的线程就越少。下面举一个例子：比如在Web服务器处理HTTP请求时，假设平均线程CPU运行时间为100毫秒，而线程等待时间（比如包括DB操作、RPC操作、缓存操作等）为900毫秒，如果CPU核数为8，那么根据上面这个公式，估算如下：

     (900毫秒 + 100毫秒) / 100毫秒 * 8 = 10 * 8 = 80

---
混合型任务线程池：
```java

public class ThreadUtil
{
    private static final int MIXED_MAX = 128;  //最大线程数
    private static final String MIXED_THREAD_AMOUNT = "mixed.thread.amount";

    //懒汉式单例创建线程池：用于混合型任务
    private static class MixedTargetThreadPoolLazyHolder
    {
        //首先从环境变量 mixed.thread.amount 中获取预先配置的线程数
        //如果没有对 mixed.thread.amount进行配置，就使用常量 MIXED_MAX作为线程数
        private static final int max = 
                        (null != System.getProperty(MIXED_THREAD_AMOUNT)) ?
                Integer.parseInt(System.getProperty(MIXED_THREAD_AMOUNT))
                                                                    : MIXED_MAX;
        //线程池：用于混合型任务
        private static final ThreadPoolExecutor EXECUTOR = 
                                                        new ThreadPoolExecutor(
                max,
                max,
                KEEP_ALIVE_SECONDS,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue(QUEUE_SIZE),
                new CustomThreadFactory("mixed"));

        static
        {
            EXECUTOR.allowCoreThreadTimeOut(true);
            //JVM关闭时的钩子函数
            Runtime.getRuntime().addShutdownHook(
                new ShutdownHookThread("混合型任务线程池", new Callable<Void>()
            {
                @Override
                public Void call() throws Exception
                {
                    //优雅地关闭线程池
                    shutdownThreadPoolGracefully(EXECUTOR);
                    return null;
                }
            }));
        }
    }
    // 省略不相干代码
}


```
    