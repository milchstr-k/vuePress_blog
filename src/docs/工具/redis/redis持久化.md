# 持久化
redis数据存储在内存中，为了防止宕机数据丢失，redis采用了两种持久化机制。

## 内存快照
*  一次内存数据的全量备份，是**内存数据的二进制序列化形式**

### fork(多进程)
>redis持久化会调用glibc的函数**fork**产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。

>子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存数据结构进行不间断的修改。

这个时候就会使用操作系统的**COW**机制来进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程相应的页面是没有变化的，还是进程产生时那一瞬间的数据。

随着父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的 2 倍大小。另外一个 Redis 实例里冷数据占的比例往往是比较高的，所以很少会出现所有的页面都会被分离，被分离的往往只有其中一部分页面。每个页面的大小只有 4K，一个 Redis 实例里面一般都会有成千上万的页面。

子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化叫「快照」的原因。接下来子进程就可以非常安
心的遍历数据了进行序列化写磁盘了。

## AOF
* AOF是连续的增量备份，记录**内存数据修改的指令记录文本**
* 运行过程，AOF日志会越来越大，需要定期重写，对日志进行瘦身

### 重写瘦身
**bgrewriteaof**指令用来对AOF日志瘦身，开辟一个子进程对内存进行遍历转换成一系列redis操作指令，序列化一个新的AOF日志中。序列化完毕后将**操作期间发生的增量AOF日志追加到这个新的AOF日志中，追加完毕后立刻替代旧的AOF日志文件**

### fsync
* 文件写入
    程序对AOF日志文件进行写操作时，将内容写到了内核为文件描述符分配的一个内存缓存中，**内核会异步将脏数据刷回到磁盘中**
* 何时写入
    Linux 的 glibc 提供了 fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷到磁盘
* 保证性能
    fsync是磁盘IO操作，所以在生产环境的服务器中，Redis 通常是每隔 1s 左右执行一次 fsync 操作，周期 1s是可配置的。
* 写入策略
    * 永不 fsync——让操作系统来决定合适同步磁盘，很不安全
    * 来一个指令就 fsync 一次——非常慢
    * 自定义配置fsync时间


## redis4.0 混合持久化

将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。

