



## 数据库种类

数据库锁有**排他锁、共享锁、意向锁、自增锁、间隙锁**，锁的范围包括**行锁、表锁、区间锁**。

意向锁、自增锁、间隙锁是mysql内部逻辑锁，排他锁和共享锁是使用过程中用户添加的锁。

## 排他锁

排他锁也被称为X锁（共享锁是S锁），加锁前需要**开启事务**，**for update语句在事务中有效**。如果事务A成功获取锁，其他事务无法对这条记录进行加锁（排他锁、共享锁），可以无锁查询。

### 使用

* 无锁

|事务1|事务2|
|--|--|
|step1:查询金额200| |
|step2:内存计算200-100=100| step1: 查询金额200|
|step3:更新数据库金额100| step2: 内存计算200+50=250|
|step4:commit|step3:更新数据金额250|
| | step4: commit|

现实场景中，金额期望150，但实际现在为250。

* 加锁

|事务1|事务2|
|--|--|
|step1:查询金额200（加锁）| |
|step2:内存计算200-100=100| step1: 查询金额200(加锁)|
|step3:更新数据库金额100| setp2: 等待|
|step4:commit|step3: 等待|
| | step4: 返回金额100元 |
| | step5: 内存计算+50=150|
| | setp6: 更新余额150元|
| | setp7: commit|

保持金额的一致性，当A事务加了排他锁后其他事务只能等待直到A事务提交。


## 共享锁

共享锁又被成为S锁，相对于悲观锁来说，是低一级的锁。事务A对某一条数据加了共享锁后，其他事务依旧可以增加共享锁，但是不能增加排他锁。

|           | 共享锁（S）| 排它锁（X）|
|--|--|--|
|共享锁（S）| √ | X |
|排他锁（X）| X | X | 

### 使用

排他锁保证一张表中数据一致性，共享锁保证主从表的一致性。

有用户user表和用户联系人user_relation表

todo

### 共享锁升级导致死锁

#### 共享锁升级

当获取到共享锁后对获得锁的数据进行更新，共享锁会**升级排他锁**，可能导致死锁现象。

#### 升级导致死锁

共享锁可以被多个事务同时获得，如果多个事务获得共享锁后同时进行更新，则会导致死锁。

|事务1|事务2|
|--|--|
|select * from account where ? lock in share mode返回200元| |
|内存计算：200-100=100| select * from account where ? lock in share mode返回200元 |
|update account set balance = 100 where user=A，更新余额100元|内存计算：200-100=100|
|尝试锁升级成排他锁，等待事务2释放共享锁| update account set balance = 100 where user=A，更新余额100元|
|等待 | 尝试锁升级成排他锁 等待事务 T1 释放|
|等待| 检测出死锁，事务失败，roll back|
|获得锁成功， 更新成功| |
|commit| |



## 意向锁

意向锁（intention lock）分为**IS共享意向锁** 和 **IX排他意向锁**。意向锁表示表中有记录被锁了，记录被加了排他锁，则表上会有IX锁，记录加了共享锁，则表上有IS锁。

### 解决问题

mysql中支持行锁和表锁，当事务A加了行锁后，事务B此时想要加表锁，在没有意向锁的情况下，需要循环表的每一条记录判断是否加锁，最后确定能否加表锁，效率低。

当给记录加锁时，会在表上先加意向锁，代表这个表中某条记录被加锁。当其他事务来对表进行加锁的时候，只需要判断表上是否有意向锁，就可以对表进行加锁。

### 互斥性

todo


## 间隙锁

### 介绍

解决mysql在可重复读级别下部分幻读问题。间隙锁在**范围查询加锁或查询不存在值加锁时使用**，用于锁定一定范围数据，防止其他事务写入，解决幻读问题。

### 解决幻读


